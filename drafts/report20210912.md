# Неделя 06.09.2021 - 12.09.2021

## Идеи, связанные со структурными изменениями. 

Некоторое предисловие. Вспоминая использование интерфейсов на курсе АиСД, можно сделать вывод о том,
что создание интерфейсов обеспечивает полиморфмизм и объединение наследников класса по некоторому
логическому признаку в группу, а также даёт явно понять, что наследники способны рассширить функционал
родителя. 

Теперь к делу и по порядку. В корне нашего дерева наследования лежит чисто абстрактный класс **IObj**,
который, по большому счёту, репрезентирует `базовые объекты взаимодействия в игре`. Отдельно подчёркиваю
этот факт, поскольку этот принцип удовлетворяет условию наследования, дочерние классы объединяются в 
некоторую логическую группу, тут спорить бессмысленно. Далее. Детально рассмотрим наследников. К ним 
относятся: **IController**, **IHandler**, **IEngine**, **IGameObj**. 

**IController** занимается манипулированием игровым объектом, с которым он двунаправленно связан, 
для упрощённого представления будем думать о контроллере, как о корабельном пульте и штурвале, управляющем 
кораблём. 

**IHandler** осуществляет обработку событий. Его мы представим, как рулевого, вращающего штурвал,
переключающегося между работами двигателя по приказу капитана - пользователя. Это так, поскольку 
ему необходимо обработать входную информацию - приказ - пользователя, и в зависимости от неё дать 
команду контроллеру - пульту и штурвалу. 

**IEngine** - двигатель коробля в нашей интерпретации, поскольку он занимается расчётами, физикой,
графикой, звуком и т.д. Т.е. это каркас, на который натянута игра. 

**IGameObj** - это сам корабль, поскольку он управляется пользователем посредством контроллеров, 
хэндлеров и в зависимости от того, как отработал двигатель. 

К чему это всё, к тому, что неясно, какой полиморфизм должны поддерживать корабль, двигатель, пульт управления
и рулевой? Как можно объединить их функционал в базовый интерфейс? Точно ли наследники расширяют базовый функционал,
а не создают свой? Как в программе планируется использоваться факт того, что эти классы - наследники базового?
К тому же с точки зрения С++ отныне объекты дочерних классов будут занимать больше места в памяти, поскольку 
будут хранить в себе данные IObj, а это, как минимум указатель на виртуальную таблицу, т.е. 8 байт. И эти лишние 8 байт 
будут храниться в каждом объекте игры от движка до сундука на поле. 

**Я предлегаю** не заигрываться с наследованием и просто разбить интерфейсы на контроллеры, хендлеры, объекты и движки. 
Мне кажется это достаточно логичным решением, которое к тому же является более экономичным. В целом, если посидеть и 
подумать, возможно, удасться избавиться от лишнего наследования в ещё в некоторых местах, но пока я предлагаю исключить IObj
из нашей схемы, в обоснование чего приведены доводы выше. 

## Идеи, связанные с картами. 

В теории это должно выглядеть так: World -> Static / Dynamic Area -> Chunk. 

World условно раздроблен сеткой, клетками этой сетки являются Static Areas. Размеры Static Areas совпадают с размерами
1920px x 1080px. Это нужно, чтобы генерировать буферные зоны вокруг игрока, предобработанные движком. Далее, Dynamic Area - 
это отрендеренная Area , отображающаяся на экране, в отличие от Static она перемещается за игроком, всё, в рамках неё - 
видимые объекты, а не просто просчитываемые модельки. Chunk - обстракция над Dynamic Area, игровые области размером
120px на 120px, нужны для облегчённого поиска объектов. 

Пока что я не могу дать определённого ответа на вопрос, а как это должно храниться, но я думаю, мы придумаем что-нибудь.

## Остальное. 

Далее без изменений. С видением игрового цикла, как получения событий через адаптер, помещения их в очередь с приоритетом,
а затем обработку, я согласен. 

Пара слов про математическую библиотеку. Нужно строго определиться с системами координат, чтобы понять, что конкретно должны
уметь наши векторы и алгоритмы, а также оптимизировать из, исходя из координатной сетки. 